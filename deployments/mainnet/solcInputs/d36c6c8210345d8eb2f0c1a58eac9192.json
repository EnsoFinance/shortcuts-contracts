{
  "language": "Solidity",
  "sources": {
    "contracts/helpers/TupleHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n/**\n  * @notice Helper contract to extract a variety of types from a tuple within the context of a weiroll script\n  */\ncontract TupleHelpers {\n\n    /**\n      * @notice Extract a bytes32 encoded static type from a tuple\n      * @dev Use with .rawValue() in the weiroll planner\n      * @param tuple The bytes encoded tuple\n      * @param index The index of the value to be extracted\n      */\n    function extractElement(bytes memory tuple, uint256 index) public pure returns (bytes32) {\n        assembly {\n            // let offset := mul(add(index, 1), 32)\n            // return(add(tuple, offset), 32)\n            return(add(tuple, mul(add(index, 1), 32)), 32)\n        }\n    }\n\n    /**\n      * @notice Extract a bytes encoded dynamic type from a tuple\n      * @dev Use with .rawValue() in the weiroll planner\n      * @param tuple The bytes encoded tuple\n      * @param index The index of the string or bytes to be extracted\n      */\n    function extractDynamicElement(bytes memory tuple, uint256 index) public pure returns (bytes32) {\n        assembly {\n            let offset := add(mload(add(tuple, mul(add(index, 1), 32))), 32)\n            let length := mload(add(tuple, offset))\n            if gt(mod(length, 32), 0) {\n              length := mul(add(div(length, 32), 1), 32)\n            }\n            return(add(tuple, add(offset, 32)), length)\n        }\n    }\n\n    /**\n      * @notice Extract a bytes encoded tuple from another tuple\n      * @dev Use with .rawValue() in the weiroll planner\n      * @param tuple The bytes encoded parent tuple\n      * @param index The index of the tuple to be extracted\n      * @param isDynamicTypeFormat Boolean to define whether the child tuple is dynamically sized. If the child tuple contains bytes or string variables, set to \"true\"\n      */\n    function extractTuple(\n        bytes memory tuple,\n        uint256 index,\n        bool[] memory isDynamicTypeFormat\n    ) public pure returns (bytes32) {\n        uint256 offset;\n        uint256 length;\n        assembly {\n            offset := add(mload(add(tuple, mul(add(index, 1), 32))), 32)\n        }\n        for (uint256 i = 0; i < isDynamicTypeFormat.length; i++) {\n            length += 32;\n            if (isDynamicTypeFormat[i]) {\n                assembly {\n                    let paramOffset := add(offset, mload(add(tuple, add(offset, mul(i, 32)))))\n                    let paramLength := add(mload(add(tuple, paramOffset)), 32)\n                    if gt(mod(paramLength, 32), 0) {\n                      paramLength := mul(add(div(paramLength, 32), 1), 32)\n                    }\n                    length := add(length, paramLength)\n                }\n            }\n        }\n        assembly {\n            return(add(tuple, add(mload(add(tuple, mul(add(index, 1), 32))), 32)), length)\n        }\n    }\n\n    /**\n      * @notice Extract a bytes encoded static array from a tuple\n      * @dev Use with .rawValue() in the weiroll planner\n      * @param tuple The bytes encoded array\n      * @param index The index of the array to be extracted\n      */\n    function extractArray(bytes memory tuple, uint256 index) public pure returns (bytes32) {\n        assembly {\n            // let offset := add(mload(add(tuple, mul(add(index, 1), 32))), 32)\n            // let numberOfElements := mload(add(tuple, offset))\n            // return(add(tuple, add(offset, 32)), mul(numberOfElements, 32))\n            return(add(tuple, add(add(mload(add(tuple, mul(add(index, 1), 32))), 32), 32)), mul(mload(add(tuple, add(mload(add(tuple, mul(add(index, 1), 32))), 32))), 32))\n        }\n    }\n\n    /**\n      * @notice Extract a bytes encoded dynamic array from a tuple\n      * @dev Use with .rawValue() in the weiroll planner\n      * @param tuple The bytes encoded tuple\n      * @param index The index of the dynamic array to be extracted\n      */\n    function extractDynamicArray(bytes memory tuple, uint256 index) public pure returns (bytes32) {\n        uint256 numberOfElements;\n        uint256 offset;\n        assembly {\n            offset := add(mload(add(tuple, mul(add(index, 1), 32))), 32)\n            numberOfElements := mload(add(tuple, offset))\n            //numberOfElements := mload(add(tuple, add(mload(add(tuple, mul(add(index, 1), 32))), 32)))\n        }\n\n        uint256 length;\n        for (uint256 i = 1; i <= numberOfElements; i++) {\n            assembly {\n                let paramOffset := add(offset, mul(add(i, 1), 32))\n                let paramLength := mload(add(tuple, paramOffset))\n                if gt(mod(paramLength, 32), 0) {\n                  paramLength := mul(add(div(paramLength, 32), 1), 32)\n                }\n                length := add(length, paramLength)\n                //length := add(length, mload(add(tuple, add(add(mload(add(tuple, mul(add(index, 1), 32))), 32), mul(add(i, 1), 32)))))\n            }\n        }\n        assembly {\n            // return(add(tuple, add(offset, 32)), add(length, 32))\n            return(add(tuple, add(add(mload(add(tuple, mul(add(index, 1), 32))), 32), 32)), add(length, 32))\n        }\n    }\n\n    /**\n      * @notice Extract a bytes encoded array of tuples from a tuple\n      * @dev Use with .rawValue() in the weiroll planner\n      * @param tuple The bytes encoded tuple\n      * @param index The index of the tuple array to be extracted\n      * @param isDynamicTypeFormat Boolean to define whether the tuples in the array are dynamically sized. If the array tuple contains bytes or string variables, set to \"true\"\n      */\n    function extractTupleArray(\n        bytes memory tuple,\n        uint256 index,\n        bool[] memory isDynamicTypeFormat\n    ) public pure returns (bytes32) {\n        uint256 numberOfElements;\n        assembly {\n            // let offset := add(mload(add(tuple, mul(add(index, 1), 32))), 32)\n            // numberOfElements := mload(add(tuple, offset))\n            numberOfElements := mload(add(tuple, add(mload(add(tuple, mul(add(index, 1), 32))), 32)))\n        }\n        uint256 length = numberOfElements * 32;\n        for (uint256 i = 1; i <= numberOfElements; i++) {\n            for (uint256 j = 0; j < isDynamicTypeFormat.length; j++) {\n                length += 32;\n                if (isDynamicTypeFormat[j]) {\n                    assembly {\n                        // let tupleOffset := add(offset,mload(add(tuple, add(offset, mul(i, 32)))))\n                        // let paramOffset := add(tupleOffset, mload(add(tuple, add(tupleOffset, mul(add(j,1), 32)))))\n                        // let paramLength := add(mload(add(tuple, paramOffset)),32)\n                        // length := add(length, paramLength)\n                        length := add(length, add(mload(add(tuple, add(add(add(mload(add(tuple, mul(add(index, 1), 32))), 32),mload(add(tuple, add(add(mload(add(tuple, mul(add(index, 1), 32))), 32), mul(i, 32))))), mload(add(tuple, add(add(add(mload(add(tuple, mul(add(index, 1), 32))), 32),mload(add(tuple, add(add(mload(add(tuple, mul(add(index, 1), 32))), 32), mul(i, 32))))), mul(add(j,1), 32))))))),32))\n                    }\n                }\n            }\n        }\n        assembly {\n            // return(add(tuple, add(offset,32)), length)\n            return(add(tuple, add(add(mload(add(tuple, mul(add(index, 1), 32))), 32),32)), length)\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}